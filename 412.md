# 4월 12일 (월) #

### Class ###

Class = 객체의 설계도

class 멤버 = 필드 , 메소드 

메소드 method = 함수 function

복잡한 것을 정리해서 다시 단순하게 만드는 정리정돈의 도구

* this
  * 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용
  * 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 사용

### static ###

* Static 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

* Static 이 붙어있으면 class 소속이고, 안붙어있으면 instance 소속이다.
* Class method 안에서는 instance 변수에러, instance method 안에서는 class 변수와 instance 변수 모두 사용 가능
* 필드를 선언할 때 인스턴스 필드로 선언 할 것인가? 정적 필드로 선언할 것인가? 
  * 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언
  * 객체마다 가지고 있을 필요가 없는 공용 데이터라면 정적필드로 선언 하는 것이 좋다. 

* 메소드를 선언할 때 인스턴스 메소드로 선언 할 것인가? 정적 메소드로 선언할 것인가? 
  * 인스턴스 필드를 포함하고 있다면 인스턴스 메소드로 선언
  * 인스턴스 필드를 포함하고 있지 않다면 정적 메소드로 선언



### 싱글톤 ###

* 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우

  단 하나만 생성되는 객체를 싱글톤이라 한다.



### final 필드 ###

* 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드



### 접근 제한자 ###

* Public : 외부 클래스가 자유롭게 사용할 수 있다
* Protected : 같은 패키지 or 자식 클래스에서 사용할 수 있다
* private : 외부에서 사용할 수 없다

* default : 같은 패키지에 소속된 클래스에서만 사용할 수 있다
  * 클래스를 선언할 때 public을 생략하면 자동적으로 default 가 됨



### Getter, Setter ###

일반적으로 객체 지향 프로그래밍에서는 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막는다. 외부에서 마음대로 변경하지 못하게 하기 위해

* getter : 필드의 값을 외부로 리턴해주는 메소드
* setter : 외부에서 값을 받아 필드르 변경하는 메소드



### 다형성 ###

다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.

* 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일하다
* 자식 클래스는 부모의 메소드를 재정의해서 메소드의 샐행 내용을 변경함으로써 더 우수한 실행결과가 나오게 할 수도 있다
* 자식 타입을 부모 타입으로 변환할 수 있다



### abstract ###

상속을 강제하는 일종의 규제. Abstract 클래스나 메소드를 사용하기 위해서는 반드시 상속해서 사용하도록 강제하는 것



### 인터페이스 ###

개발 코드와 객체가 서로 통신하는 접점 역할

개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해 사용

개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출 시킨다. 구성멤버는 상수 필드와 추상 메소드이다.



 ### 예외 클래스 ###

* 일반 예외
* 실행 예외
  * 자바 컴파일러가 체크하지 않기 때문에 개발자의 경험에 의해서 예외 처리 코드를 작성해야 한다.
  * NullPointException : null 값을 갖는 참조 변수로 객체 접근 연산자인 도트(.)를 사용했을 때 발생. 객체가 없는 상태에서 객체를 사용하려 했으니 예외가 발생
  * ArrayIndexOutOfBoundsException : 배열에서 인덱스 범위를 초과할 경우 
  * NumberFormatException : ?
  * ClassCastException : 캐스팅 관계가 아닌 경우



* 예외 처리 코드
  * Try-catch-finally 블록

``` java
try {
  예외 발생 가능 코드
} catch(예외클래스 e) {
  예외 처리
}finally {
  항상 실행;
}
```

* 예외 떠넘기기

```java
리턴타입 메소드이름() throws 예외클래스 { }
```

메소드를 호출한 곳으로 예외를 떠넘긴다